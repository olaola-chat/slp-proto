// ============================================================================
// This is auto-generated by gf cli tool only once. Fill this file as you wish.
// ============================================================================

package dao

import (
	"context"

	"banban/app/dao/internal"
	"banban/app/pb"

	"github.com/gogf/gf/database/gdb"
	"github.com/gogf/gf/frame/g"
	"github.com/gogf/gf/util/gconv"
)

// xsGroupUserDao is the manager for logic model data accessing
// and custom defined data operations functions management. You can define
// methods on it to extend its functionality as you wish.
type xsGroupUserDao struct {
	internal.XsGroupUserDao
}

var (
	// XsGroupUser is globally public accessible object for table xs_group_user operations.
	XsGroupUser = xsGroupUserDao{
		internal.XsGroupUser,
	}
)

// Fill with you ideas below.

func GetGroupUser(ctx context.Context, groupId, uid uint32) (*pb.EntityXsGroupUser, error) {
	if groupId < 1 || uid < 1 {
		return nil, nil
	}
	groupUser, err := XsGroupUser.Ctx(ctx).One("group_id=? and uid=?", groupId, uid)
	if err != nil {
		if err == gdb.ErrNoRows {
			err = nil
		} else {
			g.Log().Errorf("get XsGroupUser failed:%v", err)
		}
	}
	return groupUser, err
}

// GetRecords 获取用户临时群
func (*xsGroupUserDao) GetRecords(ctx context.Context, uid uint32, minId uint64, limit int) []*pb.FamiliarItem {
	var records []*pb.FamiliarItem
	if uid > 0 {
		recs, err := XsGroupUser.Ctx(ctx).Order("id asc").Limit(limit).FindAll("uid = ? AND is_tmp = 1 AND id > ?", uid, minId)
		if err != nil {
			return records
		}
		for _, rec := range recs {
			isFamiliar := false
			if rec.Deleted == 0 {
				isFamiliar = true
			}
			records = append(records, &pb.FamiliarItem{
				Id:       gconv.Uint64(rec.Id),
				ToId:     rec.GroupId,
				Familiar: isFamiliar,
				Time:     rec.Dateline,
			})
		}
	}
	return records
}

// GetMultiMembersMap 每个群最多查询多少个用户
// todo 这里循环查了数据库
func (*xsGroupUserDao) GetMultiMembersMap(ctx context.Context, groupIds []uint32, limit uint32) map[uint32][]*pb.EntityXsGroupUser {
	ret := make(map[uint32][]*pb.EntityXsGroupUser)
	for _, groupId := range groupIds {
		records, err := XsGroupUser.Ctx(ctx).Order("id ASC").Limit(int(limit)).FindAll("group_id = ? AND deleted = 0", groupId)
		if err == nil && len(records) > 0 {
			ret[groupId] = records
		}
	}
	return ret
}
