// ============================================================================
// This is auto-generated by gf cli tool only once. Fill this file as you wish.
// ============================================================================

package dao

import (
	"banban/app/dao/internal"
	"banban/app/pb"
	"banban/library"
	"context"
	"encoding/json"
	"fmt"
	"time"
)

// xsUserTagInfoDao is the manager for logic model data accessing
// and custom defined data operations functions management. You can define
// methods on it to extend its functionality as you wish.
type xsUserTagInfoDao struct {
	internal.XsUserTagInfoDao
}

var (
	// XsUserTagInfo is globally public accessible object for table xs_user_tag_info operations.
	XsUserTagInfo = xsUserTagInfoDao{
		internal.XsUserTagInfo,
	}
)

// Fill with you ideas below.
// 获取用户标签列表
func (d *xsUserTagInfoDao) GetTagList(ctx context.Context, uid uint32) []*pb.UserTagData {
	var data []*pb.UserTagData
	redis := library.RedisClient(library.RedisCache)
	key := d.GetTagListCacheKey(uid)
	res, _ := redis.Get(ctx, key).Result()
	if len(res) == 0 {
		rows, err := d.Ctx(ctx).Order("id desc").All("uid = ? AND deleted = 0", uid)
		if err != nil || rows == nil {
			return nil
		}
		for _, val := range rows {
			data = append(data, &pb.UserTagData{Id: val.Id, Name: val.Name})
		}
		dataJson, _ := json.Marshal(data)
		redis.Set(ctx, key, dataJson, time.Second*300)
		return data
	}
	err := json.Unmarshal([]byte(res), &data)
	if err != nil {
		return nil
	}
	return data
}

func (d *xsUserTagInfoDao) GetTagListCacheKey(uid uint32) string {
	return fmt.Sprintf("Xs.User.Tag.List.%d", uid)
}

func (d *xsUserTagInfoDao) RefreshTagList(ctx context.Context, uid uint32) error {
	redis := library.RedisClient(library.RedisCache)
	key := d.GetTagListCacheKey(uid)
	redis.Del(ctx, key)
	return nil
}
