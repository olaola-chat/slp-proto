// ============================================================================
// This is auto-generated by gf cli tool only once. Fill this file as you wish.
// ============================================================================

package dao

import (
	"context"
	"fmt"
	"time"

	"banban/app/dao/internal"
	"banban/app/pb"

	"github.com/gogf/gf/database/gdb"
	"github.com/gogf/gf/frame/g"
	"github.com/gogf/gf/os/gcache"
)

// xsGameDao is the manager for logic model data accessing
// and custom defined data operations functions management. You can define
// methods on it to extend its functionality as you wish.
type xsGameDao struct {
	internal.XsGameDao
}

var (
	// XsGame is globally public accessible object for table xs_game operations.
	XsGame = xsGameDao{
		internal.XsGame,
	}
)

// Fill with you ideas below.

// GetGamesAll 只有 id,name,icon 三个字段
func GetGamesAll(ctx context.Context) ([]*pb.EntityXsGame, error) {
	val, err := gcache.GetOrSetFunc("Xs.Games.V2.Go", func() (interface{}, error) {

		data, err := XsGame.Ctx(ctx).Fields("id,name,icon").All("deleted=0")
		if err != nil && err != gdb.ErrNoRows {
			g.Log().Error(err)
			return nil, err
		}

		return data, nil

	}, time.Second*3600)

	if err != nil {
		return nil, err
	}

	if val == nil {
		return nil, nil
	}

	return val.([]*pb.EntityXsGame), nil
}

type BriefGame struct {
	GameId    uint32
	Num       int32
	EscapeNum int32
	WinNum    int32
	Name      string
	Icon      string
	Dateline  int32
}

func GetGamesBriefByUid(ctx context.Context, uid uint32) []*BriefGame {

	games, _ := GetGamesAll(ctx)

	if len(games) < 1 {
		return nil
	}

	v, _ := gcache.GetOrSetFunc(fmt.Sprintf("Xs.GameUser.Get.%v", uid), func() (interface{}, error) {

		gu, err := XsGameUser.Ctx(ctx).All("uid=?", uid)
		if err != nil && err != gdb.ErrNoRows {
			g.Log().Error(err)
			return nil, nil
		}

		return gu, nil

	}, time.Second*60)

	if v == nil {
		return nil
	}

	gus := v.([]*pb.EntityXsGameUser)
	if len(gus) < 1 {
		return nil
	}

	guMapOnGameId := make(map[int32]*pb.EntityXsGameUser)

	for _, gu := range gus {
		guMapOnGameId[gu.GameId] = gu
	}

	res := make([]*BriefGame, 0)

	for _, game := range games {

		if gu := guMapOnGameId[game.Id]; gu != nil {

			res = append(res, &BriefGame{
				GameId:    uint32(game.Id),
				Num:       gu.Num,
				EscapeNum: gu.EscapeNum,
				WinNum:    gu.WinNum,
				Name:      game.Name,
				Icon:      game.Icon,
				Dateline:  gu.Dateline,
			})

		} else {
			res = append(res, &BriefGame{
				GameId: uint32(game.Id),
				Name:   game.Name,
				Icon:   game.Icon,
			})
		}

	}

	return res

}
