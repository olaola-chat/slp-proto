// ============================================================================
// This is auto-generated by gf cli tool only once. Fill this file as you wish.
// ============================================================================

package dao

import (
	"banban/app/dao/internal"
	"banban/app/pb"
	"banban/library"
	"context"
	"encoding/json"
	"fmt"
	"time"
)

// xsScreenQuickMessageDao is the manager for logic model data accessing
// and custom defined data operations functions management. You can define
// methods on it to extend its functionality as you wish.
type xsScreenQuickMessageDao struct {
	internal.XsScreenQuickMessageDao
}

var (
	// XsScreenQuickMessage is globally public accessible object for table xs_screen_quick_message operations.
	XsScreenQuickMessage = xsScreenQuickMessageDao{
		internal.XsScreenQuickMessage,
	}
)

// Fill with you ideas below.
// 获取用户公屏快捷消息
func (d *xsScreenQuickMessageDao) GetMessageList(ctx context.Context, uid uint32) []*pb.ScreenQuickMsgData {
	var data []*pb.ScreenQuickMsgData
	redis := library.RedisClient(library.RedisCache)
	key := d.GetMessageListCacheKey(uid)
	res, _ := redis.Get(ctx, key).Result()
	if len(res) == 0 {
		rows, err := d.Ctx(ctx).Order("weight desc").All("uid = ? AND deleted = 0", uid)
		if err != nil || rows == nil {
			return nil
		}
		for _, val := range rows {
			data = append(data, &pb.ScreenQuickMsgData{Id: val.Id, Content: val.Content})
		}
		dataJson, _ := json.Marshal(data)
		redis.Set(ctx, key, dataJson, time.Second*300)
		return data
	}
	err := json.Unmarshal([]byte(res), &data)
	if err != nil {
		return nil
	}
	return data
}

func (d *xsScreenQuickMessageDao) GetMessageListCacheKey(uid uint32) string {
	return fmt.Sprintf("Xs.Screen.Quick.Msg.%d", uid)
}

func (d *xsScreenQuickMessageDao) RefreshMessageList(ctx context.Context, uid uint32) error {
	redis := library.RedisClient(library.RedisCache)
	key := d.GetMessageListCacheKey(uid)
	redis.Del(ctx, key)
	return nil
}
