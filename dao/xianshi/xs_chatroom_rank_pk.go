// ============================================================================
// This is auto-generated by gf cli tool only once. Fill this file as you wish.
// ============================================================================

package dao

import (
	"banban/app/dao/internal"
	"banban/app/pb"
	"banban/library"
	"context"
	"fmt"

	"github.com/gogf/gf/util/gconv"
)

// xsChatroomRankPkDao is the manager for logic model data accessing
// and custom defined data operations functions management. You can define
// methods on it to extend its functionality as you wish.
type xsChatroomRankPkDao struct {
	internal.XsChatroomRankPkDao
}

var (
	// XsChatroomRankPk is globally public accessible object for table xs_chatroom_rank_pk operations.
	XsChatroomRankPk = xsChatroomRankPkDao{
		internal.XsChatroomRankPk,
	}
)

// Fill with you ideas below.

// 获取PK榜key
func (d *xsChatroomRankPkDao) GetPKRankListKey(rid uint32, pkVersion uint32) string {
	return fmt.Sprintf("Xs.Ktv.Pk.Rank.List.%d.%d", rid, pkVersion)
}

// 获取PK 配置
func (d *xsChatroomRankPkDao) GetPkRankConfig(ctx context.Context, rid uint32) *pb.EntityXsChatroomRankPk {
	config, err := XsChatroomRankPk.Ctx(ctx).One("rid = ?", rid)
	if err != nil || config == nil {
		return nil
	}

	return config
}

// 获取PK RANK 排行榜
func (d *xsChatroomRankPkDao) GetPkRankList(ctx context.Context, rid uint32, pkVersion uint32) (map[uint32]uint32, []uint32) {
	var limit int64 = 99
	var start int64 = 0
	rankKey := d.GetPKRankListKey(rid, pkVersion)
	redisClient := library.RedisClient(library.RedisCache)

	stop := start + limit - 1
	userScores, err := redisClient.ZRevRangeWithScores(ctx, rankKey, start, stop).Result()
	if err != nil || len(userScores) == 0 {
		return nil, nil
	}

	uids := []uint32{}
	uidScoreMap := make(map[uint32]uint32)
	for _, val := range userScores {
		uid := gconv.Uint32(val.Member)
		uidScoreMap[uid] = gconv.Uint32(val.Score)
		uids = append(uids, uid)
	}

	return uidScoreMap, uids
}
