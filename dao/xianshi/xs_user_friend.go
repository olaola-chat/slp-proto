// ============================================================================
// This is auto-generated by gf cli tool only once. Fill this file as you wish.
// ============================================================================

package dao

import (
	"context"
	"fmt"

	"banban/app/dao/internal"
	"banban/app/pb"

	"github.com/gogf/gf/database/gdb"
	"github.com/gogf/gf/frame/g"
)

// xsUserFriendDao is the manager for logic model data accessing
// and custom defined data operations functions management. You can define
// methods on it to extend its functionality as you wish.
type xsUserFriendDao struct {
	internal.XsUserFriendDao
}

var (
	// XsUserFriend is globally public accessible object for table xs_user_friend operations.
	XsUserFriend = xsUserFriendDao{
		internal.XsUserFriend,
	}
)

// Fill with you ideas below.

func IsMeFollowUid(ctx context.Context, me, uid uint32) (bool, error) {
	if uid < 1 {
		return false, nil
	}
	f, err := XsUserFriend.Ctx(ctx).Fields("uid").One("uid=? and `to`=?", me, uid)
	if err != nil && err != gdb.ErrNoRows {
		return false, fmt.Errorf("execute isPopularUserStmt failed:%v", err)
	}
	if f == nil {
		return false, nil
	}
	return f.Uid > 0, nil
}

func MeFollowUidsInfo(ctx context.Context, me uint32, uids []uint32) (uidsInfoMap map[uint32]*pb.EntityXsUserFriend, err error) {
	if len(uids) < 1 || me < 1 {
		return
	}
	uidsInfo, err := XsUserFriend.Ctx(ctx).All("uid=? and `to` in (?)", me, uids)
	if err != nil {
		g.Log().Errorf("XsUserFriend failed:%v", err)
		return nil, err
	}
	uidsInfoMap = make(map[uint32]*pb.EntityXsUserFriend)
	if len(uidsInfo) < 1 {
		return
	}
	for _, u := range uidsInfo {
		if u.To > 0 {
			uidsInfoMap[uint32(u.To)] = u
		}
	}
	return
}
