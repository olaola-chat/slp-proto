// ============================================================================
// This is auto-generated by gf cli tool only once. Fill this file as you wish.
// ============================================================================

package dao

import (
	"banban/app/dao/internal"
	"banban/library"
	"context"
	"time"

	"github.com/gogf/gf/util/gconv"
)

// xsUserTitleDao is the manager for logic model data accessing
// and custom defined data operations functions management. You can define
// methods on it to extend its functionality as you wish.
type xsUserTitleDao struct {
	internal.XsUserTitleDao
}

var (
	// XsUserTitle is globally public accessible object for table xs_user_title operations.
	XsUserTitle = xsUserTitleDao{
		internal.XsUserTitle,
	}
)

// Fill with you ideas below.

const (
	USER_TITLE_NEW_KEY            = "xs.user.title.new.v1"
	USER_TITLE_SUBSCRIBE_TIME_KEY = "xs.user.title.new.subscribe.time.v1"
)

func (title *xsUserTitleDao) MGetUserTitleLevelFromCache(ctx context.Context, uids []uint32) map[uint32]uint32 {
	ret := make(map[uint32]uint32)
	if len(uids) == 0 {
		return ret
	}
	redis := library.RedisClient(library.RedisCache)
	uIdsVal := gconv.Strings(uids)
	subscribeTimes := make(map[uint32]int64)
	tList, _ := redis.HMGet(ctx, USER_TITLE_SUBSCRIBE_TIME_KEY, uIdsVal...).Result()
	for idx, t := range tList {
		if t == nil {
			continue
		}
		u := gconv.Uint32(uids[idx])
		subscribeTimes[u] = gconv.Int64(t)
	}

	hasTitleIds := make([]string, 0)
	now := time.Now().Unix()
	for _, v := range uids {
		if subscribeTimes[v] > now {
			hasTitleIds = append(hasTitleIds, gconv.String(v))
		}
	}

	if len(hasTitleIds) == 0 {
		return ret
	}
	levels, _ := redis.HMGet(ctx, USER_TITLE_NEW_KEY, hasTitleIds...).Result()
	for idx, v := range levels {
		if v == nil {
			continue
		}
		uid := gconv.Uint32(hasTitleIds[idx])
		ret[uid] = gconv.Uint32(v)
	}
	return ret
}
