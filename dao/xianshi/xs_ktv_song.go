// ============================================================================
// This is auto-generated by gf cli tool only once. Fill this file as you wish.
// ============================================================================

package dao

import (
	"banban/app/dao/internal"
	"banban/app/pb"
	"banban/library"
	"banban/library/tool"
	"banban/rpc/client"
	"context"
	"encoding/json"
	"fmt"
	"github.com/gogf/gf/container/gset"
	"github.com/gogf/gf/util/gconv"
)

// xsKtvSongDao is the manager for logic model data accessing
// and custom defined data operations functions management. You can define
// methods on it to extend its functionality as you wish.
type xsKtvSongDao struct {
	internal.XsKtvSongDao
}

var (
	// XsKtvSong is globally public accessible object for table xs_ktv_song operations.
	XsKtvSong = xsKtvSongDao{
		internal.XsKtvSong,
	}
)

// Fill with you ideas below.
// 从缓存获取本周演唱榜
func (d *xsKtvSongDao) GetWeekSingerRankByCache(ctx context.Context, appId int32) []*pb.KtvThisWeekRankData {
	stime := tool.Date.GetWeekStartTime(0).Unix()
	cacheKey := d.GetWeekRankListKey(stime, appId)
	redisClient := library.RedisClient(library.RedisCache)
	cacheJson, err := redisClient.Get(ctx, cacheKey).Result()
	if err != nil {
		return nil
	}
	var data []*pb.KtvThisWeekRankData
	err = json.Unmarshal([]byte(cacheJson), &data)
	if err != nil {
		return nil
	}
	return data
}

// 获取本周演唱榜
func (d *xsKtvSongDao) GetWeekSingerRank(ctx context.Context, appId int32, limit int64) []*pb.KtvThisWeekRankData {
	stime := tool.Date.GetWeekStartTime(0).Unix()
	weekRankKey := d.GetWeekSingerRankKey(stime, appId)
	redisClient := library.RedisClient(library.RedisCache)
	var start int64 = 0
	stop := start + limit - 1
	uidScores, err := redisClient.ZRevRangeWithScores(ctx, weekRankKey, start, stop).Result()
	if err != nil || len(uidScores) == 0 {
		return nil
	}
	var (
		uids       []uint32
		songIdSet  = gset.New(true)
		songNumMap = make(map[uint32]int64)
		songIdMap  = make(map[uint32]uint32)
	)
	for _, val := range uidScores {
		uid := gconv.Uint32(val.Member)
		uids = append(uids, uid)
		//用户演唱的歌曲
		userSingKey := d.GetWeekUserSingRankKey(uid, stime)
		songNum := redisClient.ZCard(ctx, userSingKey).Val()
		songNumMap[uid] = songNum
		songIds := redisClient.ZRevRange(ctx, userSingKey, 0, 0).Val()
		if len(songIds) > 0 {
			for _, songId := range songIds {
				songIdSet.Add(songId)
			}
			songIdMap[uid] = gconv.Uint32(songIds[0])
		}
	}
	var profileMap = make(map[uint32]*pb.EntityXsUserProfile)
	profiles, err := client.UserProfile.Mget(ctx, uids, []string{})
	if err == nil && len(profiles) > 0 {
		for _, user := range profiles {
			profileMap[user.Uid] = user
		}
	}
	songList, err := XsKtvSong.Ctx(ctx).All("id IN (?)", songIdSet.Slice())
	if err != nil || len(songList) == 0 {
		return nil
	}
	var songMap = make(map[uint32]*pb.EntityXsKtvSong)
	for _, song := range songList {
		songMap[song.Id] = song
	}
	var data []*pb.KtvThisWeekRankData
	for k, val := range uidScores {
		var rankInfo = new(pb.KtvThisWeekRankData)
		rankInfo.Rank = uint32(k) + 1
		rankInfo.Uid = gconv.Uint32(val.Member)
		if user, ok := profileMap[rankInfo.Uid]; ok {
			rankInfo.Name = user.Name
			rankInfo.Icon = user.Icon
		}
		rankInfo.Score = gconv.Uint32(val.Score)
		userSongId := songIdMap[rankInfo.Uid]
		var desc string
		if userSongId > 0 {
			if song, ok := songMap[userSongId]; ok {
				desc = fmt.Sprintf("%s 等%d首", song.Name, songNumMap[rankInfo.Uid])
			}
			rankInfo.Desc = desc
		}
		data = append(data, rankInfo)
	}
	return data
}

// 获取本周演唱榜我的排名
func (d *xsKtvSongDao) GetWeekSingerMyRank(ctx context.Context, profile *pb.EntityXsUserProfile) *pb.KtvThisWeekRankData {
	stime := tool.Date.GetWeekStartTime(0).Unix()
	weekRankKey := d.GetWeekSingerRankKey(stime, profile.AppId)
	redisClient := library.RedisClient(library.RedisCache)
	uidStr := gconv.String(profile.Uid)

	var (
		myRank  uint32
		myScore uint32
	)
	//判断用户是否在有序集合中
	if score, err := redisClient.ZScore(ctx, weekRankKey, uidStr).Result(); err == nil {
		myIdx := redisClient.ZRevRank(ctx, weekRankKey, uidStr).Val()
		myRank = uint32(myIdx) + 1
		myScore = uint32(score)
	}
	//我获得音符最多的歌曲
	userSingKey := d.GetWeekUserSingRankKey(profile.Uid, stime)
	songNum := redisClient.ZCard(ctx, userSingKey).Val()
	songIds := redisClient.ZRevRange(ctx, userSingKey, 0, 0).Val()
	var desc string
	if len(songIds) > 0 {
		topSongId := songIds[0]
		song, err := XsKtvSong.Ctx(ctx).One("id = ?", topSongId)
		if err == nil && song != nil {
			desc = fmt.Sprintf("%s 等%d首", song.Name, songNum)
		}
	}
	data := &pb.KtvThisWeekRankData{
		Rank:  myRank,
		Uid:   profile.Uid,
		Name:  profile.Name,
		Icon:  profile.Icon,
		Score: myScore,
		Desc:  desc,
	}
	return data
}

// 获取最热单曲榜
func (d *xsKtvSongDao) GetHotSongRank(ctx context.Context, appId int32, limit int64) []*pb.KtvHotSongRankData {
	stime := tool.Date.GetWeekStartTime(0).Unix()
	rankKey := d.GetHotSongRankKey(stime, appId)
	redisClient := library.RedisClient(library.RedisCache)
	var start int64 = 0
	stop := start + limit - 1
	songScores, err := redisClient.ZRevRangeWithScores(ctx, rankKey, start, stop).Result()
	if err != nil || len(songScores) == 0 {
		return nil
	}
	var (
		songIds     []uint32
		uidSet      = gset.New(true)
		uids        []uint32
		songUserMap = make(map[uint32][]string)
	)
	for _, val := range songScores {
		songId := gconv.Uint32(val.Member)
		songIds = append(songIds, songId)
		//演唱该歌曲的前3名用户
		songRankKey := d.GetSingleSongRankKey(stime, songId, appId)
		uidSlice := redisClient.ZRevRange(ctx, songRankKey, 0, 2).Val()
		if len(uidSlice) > 0 {
			for _, uid := range uidSlice {
				uidSet.Add(uid)
			}
		}
		songUserMap[songId] = uidSlice
	}
	for _, v := range uidSet.Slice() {
		uids = append(uids, gconv.Uint32(v))
	}
	var profileMap = make(map[string]*pb.EntityXsUserProfile)
	profiles, err := client.UserProfile.Mget(ctx, uids, []string{})
	if err == nil && len(profiles) > 0 {
		for _, user := range profiles {
			uidStr := gconv.String(user.Uid)
			profileMap[uidStr] = user
		}
	}
	songList, err := XsKtvSong.Ctx(ctx).All("id IN (?)", songIds)
	if err != nil || len(songList) == 0 {
		return nil
	}
	var songMap = make(map[uint32]*pb.EntityXsKtvSong)
	for _, song := range songList {
		songMap[song.Id] = song
	}
	var data []*pb.KtvHotSongRankData
	for k, val := range songScores {
		var rankInfo = new(pb.KtvHotSongRankData)
		rankInfo.Rank = uint32(k) + 1
		rankInfo.SongId = gconv.Uint32(val.Member)
		if song, ok := songMap[rankInfo.SongId]; ok {
			rankInfo.Name = song.Name
		}
		rankInfo.Score = gconv.Uint32(val.Score)
		songUids := songUserMap[rankInfo.SongId]
		var singers []string
		if len(songUids) > 0 {
			for _, uidStr := range songUids {
				if user, ok := profileMap[uidStr]; ok {
					singers = append(singers, user.Icon)
				}
			}
			rankInfo.Singers = singers
		}
		data = append(data, rankInfo)
	}
	return data
}

// 获取单曲榜
func (d *xsKtvSongDao) GetSingleSongRank(ctx context.Context, songId uint32, appId int32, limit int64) []*pb.KtvSingleSongRankData {
	song, err := XsKtvSong.Ctx(ctx).One("id = ?", songId)
	if err != nil || song == nil {
		return nil
	}
	stime := tool.Date.GetWeekStartTime(0).Unix()
	rankKey := d.GetSingleSongRankKey(stime, songId, appId)
	redisClient := library.RedisClient(library.RedisCache)
	var start int64 = 0
	stop := start + limit - 1
	userScores, err := redisClient.ZRevRangeWithScores(ctx, rankKey, start, stop).Result()
	if err != nil || len(userScores) == 0 {
		return nil
	}
	var (
		uidSet = gset.New(true)
		uids   []uint32
	)
	for _, val := range userScores {
		uid := gconv.Uint32(val.Member)
		uids = append(uids, uid)
	}
	for _, v := range uidSet.Slice() {
		uids = append(uids, gconv.Uint32(v))
	}
	var profileMap = make(map[uint32]*pb.EntityXsUserProfile)
	profiles, err := client.UserProfile.Mget(ctx, uids, []string{})
	if err == nil && len(profiles) > 0 {
		for _, user := range profiles {
			profileMap[user.Uid] = user
		}
	}
	var data []*pb.KtvSingleSongRankData
	for k, val := range userScores {
		var rankInfo = new(pb.KtvSingleSongRankData)
		rankInfo.Rank = uint32(k) + 1
		rankInfo.Score = gconv.Uint32(val.Score)
		rankInfo.SingerUid = gconv.Uint32(val.Member)
		if user, ok := profileMap[rankInfo.SingerUid]; ok {
			rankInfo.SingerName = user.Name
			rankInfo.SingerIcon = user.Icon
		}
		data = append(data, rankInfo)
	}
	return data
}

// 获取歌曲信息
func (d *xsKtvSongDao) GetSongInfo(ctx context.Context, songId uint32) *pb.EntityXsKtvSong {
	song, err := XsKtvSong.Ctx(ctx).One("id = ?", songId)
	if err != nil || song == nil {
		return nil
	}
	return song
}

// 获取本周演唱榜key
func (d *xsKtvSongDao) GetWeekSingerRankKey(stime int64, appId int32) string {
	return fmt.Sprintf("Xs.ktv.rank.week.singer.%d.%d", stime, appId)
}

// 获取用户演唱榜key
func (d *xsKtvSongDao) GetWeekUserSingRankKey(uid uint32, stime int64) string {
	return fmt.Sprintf("Xs.ktv.rank.user.sing.%d.%d", uid, stime)
}

// 获取最热单曲榜key
func (d *xsKtvSongDao) GetHotSongRankKey(stime int64, appId int32) string {
	return fmt.Sprintf("Xs.ktv.rank.hot.song.%d.%d", stime, appId)
}

// 获取单曲榜key
func (d *xsKtvSongDao) GetSingleSongRankKey(stime int64, songId uint32, appId int32) string {
	return fmt.Sprintf("Xs.ktv.rank.single.song.%d.%d.%d", stime, songId, appId)
}

// 获取本周演唱榜单缓存key
func (d *xsKtvSongDao) GetWeekRankListKey(stime int64, appId int32) string {
	return fmt.Sprintf("Xs.ktv.rank.week.list.%d.%d", stime, appId)
}
